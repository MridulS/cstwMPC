import numpy as np
from HARKcore import AgentType, NullFunc
from HARKutilities import warnings  # Because of "patch" to warnings modules
from HARKutilities import calculateMeanOneLognormalDiscreteApprox, addDiscreteOutcomeConstantMean, createFlatStateSpaceFromIndepDiscreteProbs, setupGridsExpMult, CRRAutility, CRRAutilityP, CRRAutilityPP, CRRAutilityP_inv
from HARKinterpolation import Cubic1DInterpDecay, ConstrainedComposite, LinearInterp
from HARKsimulation import generateMeanOneLognormalDraws, generateBernoulliDraws
from copy import deepcopy

utility = CRRAutility
utilityP = CRRAutilityP
utilityPP = CRRAutilityPP
utilityP_inv = CRRAutilityP_inv

# =====================================================================
# === Classes and functions used to solve consumption-saving models ===
# =====================================================================

class ConsumerSolution():
    '''
    A class representing the solution of a single period of a consumption-saving
    problem.  The solution must include a consumption function, but may also include
    the minimum allowable money resources m_underbar, expected human wealth gothic_h,
    and the lower and upper bounds on the MPC kappa_min and kappa_max.  A value
    function can also be included.
    '''

    def __init__(self, cFunc=NullFunc, vFunc=NullFunc, m_underbar=None, gothic_h=None, kappa_min=None, kappa_max=None):
        '''
        The constructor for a new ConsumerSolution object.
        '''
        self.cFunc = cFunc
        self.vFunc = vFunc
        self.m_underbar = m_underbar
        self.gothic_h = gothic_h
        self.kappa_min = kappa_min
        self.kappa_max = kappa_max

    def distance(self,solution_other):
        '''
        Returns the distance between single period solutions as the distance
        between their consumption functions.
        '''
        return self.cFunc.distance(solution_other.cFunc)


def calculateGothicv(a_, v_next_, rho_, u_, R_, beta_, Gamma_, psi_vals_, xi_vals_, pmf_):
    '''
    Calculates the expected value from ending a period with assets a_.
    
    Parameters:
    -----------
    a_: float
        End of period assets.
    v_next_: function
        The value function in the following period.
    u_: function
        The utility function in the following period.
    R_: float
        The interest factor entering the following period.
    beta_: float
        The (effective) discount factor entering the following period.
    Gamma_: float
        The expected growth rate of permanent income entering the following period.
    psi_vals_: [float]
        A list of discrete values for the permanent shocks to income.
    xi_vals_: [float]
        A list of discrete values for the transitory shocks to income.
    pmf_: [float]
        A list of probabilities for the discrete income shocks (a probability mass function).

    Returns:
    ----------
    v: float
        Expected value when ending the period with a_ in assets.
    '''
    # Calculate the value of arriving in various states next period
    v_vals = v_next_(R_/(Gamma_*psi_vals_) * a_ + xi_vals_)

    # Compute expectation of value and return it
    v = beta_ * Gamma_ * np.dot(v_vals, pmf_)
    return v

    
    
def consumptionSavingSolverCubic(solution_tp1,income_distrib,p_zero_income,survival_prob,beta,rho,R,Gamma,constrained,a_grid):
    '''
    Solves a single period of a standard consumption-saving problem, representing
    the consumption function as a cubic spline interpolation.

    Parameters:
    -----------
    solution_tp1: ConsumerSolution
        The solution to the following period, likely generated by another call to SolveAPeriodConsumptionSaving.
    income_distrib: [[float]]
        A list containing three lists of floats, representing a discrete approximation to the income process between
        the period being solved and the one immediately following (in Solution_tp1).  Order: psi, xi, probs
    p_zero_income: float
        The probability of receiving zero income in the succeeding period.
    survival_prob: float
        Probability of surviving to succeeding period.
    beta: float
        Discount factor between this period and the succeeding period.
    rho: float
        The coefficient of relative risk aversion
    R: float
        Interest factor on assets between this period and the succeeding period: w_tp1 = a_t*R
    Gamma: float
        Expected growth factor for permanent income between this period and the succeeding period.
    constrained: bool
        Whether this individual may hold net negative assets at the end of the period.
    a_grid: [float]
        A list of end-of-period asset values (post-decision states) at which to solve for optimal consumption.

    Returns:
    -----------
    Solution_t: ConsumerSolution
        The solution to this period's problem, obtained using the method of endogenous gridpoints.
    '''

    # Define utility functions
    u = lambda c : utility(c,gam=rho) # currently unused, potentially useful for vFunc
    uP = lambda c : utilityP(c,gam=rho)
    uPP = lambda c : utilityPP(c,gam=rho)
    uPinv = lambda u : utilityP_inv(u,gam=rho)

    # Set and update values for this period
    effective_beta = beta*survival_prob
    psi_tp1 = income_distrib[0]
    xi_tp1 = income_distrib[1]
    prob_tp1 = income_distrib[2]
    cFunc_tp1 = solution_tp1.cFunc            
    psi_underbar_tp1 = np.min(psi_tp1)    
    xi_underbar_tp1 = np.min(xi_tp1)
    thorn_R = ((R*effective_beta)**(1/rho))/R

    # Update the bounding MPCs and PDV of human wealth:
    gothic_h_t = Gamma/R*(1.0 + solution_tp1.gothic_h)
    kappa_min_t = 1.0/(1.0 + thorn_R/solution_tp1.kappa_min)
    kappa_max_t = 1.0/(1.0 + (p_zero_income**(1/rho))*thorn_R/solution_tp1.kappa_max)

    # Calculate the minimum allowable value of money resources in this period
    if constrained:
        m_underbar_t = 0.0
    else:
        m_underbar_t = (solution_tp1.m_underbar - xi_underbar_tp1)*(Gamma*psi_underbar_tp1)/R

    # Define the borrowing constraint (limiting consumption function)
    constraint_t = lambda m: m - m_underbar_t

    # Find the unconstrained consumption function one step back
    c_temp = [0.0]  # Limiting consumption is zero as m approaches m lower bound
    m_temp = [m_underbar_t]  
    kappa_temp = [kappa_max_t]    
    a = np.asarray(a_grid) + m_underbar_t
    a_N = a.size
    shock_N = xi_tp1.size
    a_temp = np.tile(a,(shock_N,1))
    psi_temp = (np.tile(psi_tp1,(a_N,1))).transpose()
    xi_temp = (np.tile(xi_tp1,(a_N,1))).transpose()
    prob_temp = (np.tile(prob_tp1,(a_N,1))).transpose()
    m_tp1 = R/(Gamma*psi_temp)*a_temp + xi_temp 
    c_tp1, kappa_tp1 = cFunc_tp1.eval_with_derivative(m_tp1)
    C_tp1 = psi_temp*c_tp1
    gothicvP = effective_beta*R*Gamma**(-rho)*np.sum(uP(C_tp1)*prob_temp,axis=0)
    gothicvPP = effective_beta*R*R*Gamma**(-rho-1.0)*np.sum(uPP(C_tp1)*kappa_tp1*prob_temp,axis=0)    
    c = uPinv(gothicvP)
    dcda = gothicvPP/uPP(c)
    kappa = dcda/(dcda+1)
    m = c + a
    c_temp += c.tolist()
    m_temp += m.tolist()
    kappa_temp += kappa.tolist()
    cFunc_t_unconstrained = Cubic1DInterpDecay(m_temp,c_temp,kappa_temp,kappa_min_t*gothic_h_t,kappa_min_t)

    # Combine the constrained and unconstrained functions into the true consumption function
    cFunc_t = ConstrainedComposite(cFunc_t_unconstrained,constraint_t)

    # Store the results in a solution object and return it
    solution_t = ConsumerSolution(cFunc=cFunc_t, m_underbar=m_underbar_t, gothic_h=gothic_h_t, kappa_min=kappa_min_t, kappa_max=kappa_max_t)
    return solution_t

    
    
def consumptionSavingSolverLinear(solution_tp1,income_distrib,p_zero_income,survival_prob,beta,rho,R,Gamma,constrained,a_grid):
    '''
    Solves a single period of a standard consumption-saving problem, representing
    the consumption function as piecewise linear interpolation.

    Parameters:
    -----------
    solution_tp1: ConsumerSolution
        The solution to the following period, likely generated by another call to SolveAPeriodConsumptionSaving.
    income_distrib: [[float]]
        A list containing three lists of floats, representing a discrete approximation to the income process between
        the period being solved and the one immediately following (in Solution_tp1).  Order: psi, xi, probs
    p_zero_income: float
        The probability of receiving zero income in the succeeding period.
    survival_prob: float
        Probability of surviving to succeeding period.
    beta: float
        Discount factor between this period and the succeeding period.
    rho: float
        The coefficient of relative risk aversion
    R: float
        Interest factor on assets between this period and the succeeding period: w_tp1 = a_t*R
    Gamma: float
        Expected growth factor for permanent income between this period and the succeeding period.
    constrained: bool
        Whether this individual may hold net negative assets at the end of the period.
    a_grid: [float]
        A list of end-of-period asset values (post-decision states) at which to solve for optimal consumption.

    Returns:
    -----------
    Solution_t: ConsumerSolution
        The solution to this period's problem, obtained using the method of endogenous gridpoints.
    '''

    # Define utility functions
    u = lambda c : utility(c,gam=rho) # currently unused, potentially useful for vFunc
    uP = lambda c : utilityP(c,gam=rho)
    uPinv = lambda u : utilityP_inv(u,gam=rho)

    # Set and update values for this period
    effective_beta = beta*survival_prob
    psi_tp1 = income_distrib[0]
    xi_tp1 = income_distrib[1]
    prob_tp1 = income_distrib[2]
    cFunc_tp1 = solution_tp1.cFunc            
    psi_underbar_tp1 = np.min(psi_tp1)    
    xi_underbar_tp1 = np.min(xi_tp1)

    # Calculate the minimum allowable value of money resources in this period
    if constrained:
        m_underbar_t = 0.0
    else:
        m_underbar_t = (solution_tp1.m_underbar - xi_underbar_tp1)*(Gamma*psi_underbar_tp1)/R

    # Define the borrowing constraint (limiting consumption function)
    constraint_t = lambda m: m - m_underbar_t

    # Find the unconstrained consumption function one step back
    c_temp = [0.0]  # Limiting consumption is zero as m approaches m lower bound
    m_temp = [m_underbar_t]  
    a = np.asarray(a_grid) + m_underbar_t
    a_N = a.size
    shock_N = xi_tp1.size
    a_temp = np.tile(a,(shock_N,1))
    psi_temp = (np.tile(psi_tp1,(a_N,1))).transpose()
    xi_temp = (np.tile(xi_tp1,(a_N,1))).transpose()
    prob_temp = (np.tile(prob_tp1,(a_N,1))).transpose()
    m_tp1 = R/(Gamma*psi_temp)*a_temp + xi_temp 
    c_tp1 = cFunc_tp1(m_tp1)
    C_tp1 = psi_temp*c_tp1
    gothicvP = effective_beta*R*Gamma**(-rho)*np.sum(uP(C_tp1)*prob_temp,axis=0)
    c = uPinv(gothicvP)
    m = c + a
    c_temp += c.tolist()
    m_temp += m.tolist()
    cFunc_t_unconstrained = LinearInterp(m_temp,c_temp)

    # Combine the constrained and unconstrained functions into the true consumption function
    cFunc_t = ConstrainedComposite(cFunc_t_unconstrained,constraint_t)

    # Store the results in a solution object and return it
    solution_t = ConsumerSolution(cFunc=cFunc_t, m_underbar=m_underbar_t)
    return solution_t



# ============================================================================
# == A class for representing types of consumer agents (and things they do) ==
# ============================================================================

class ConsumerType(AgentType):
    '''
    An agent in the consumption-saving model.  His problem is defined by a sequence
    of income distributions, survival probabilities, discount factors, and permanent
    income growth rates, as well as time invariant values for risk aversion, the
    interest rate, the grid of end-of-period assets, and he is borrowing constrained.
    '''    
    
    # Define some universal values for all consumer types
    cFunc_terminal_ = Cubic1DInterpDecay([0.0, 1.0],[0.0, 1.0],[1.0, 1.0],0,1)
    constraint_terminal_ = lambda x: x
    solution_terminal_ = ConsumerSolution(cFunc=ConstrainedComposite(cFunc_terminal_,constraint_terminal_), m_underbar=0.0, gothic_h=0.0, kappa_min=1.0, kappa_max=1.0)
    time_vary_ = ['income_distrib','p_zero_income','survival_prob','beta','Gamma']
    time_inv_ = ['rho','R','a_grid','constrained']
    
    def __init__(self,cycles=1,time_flow=False,**kwds):
        '''
        Instantiate a new ConsumerType with given data.
        '''       
        # Initialize a basic AgentType
        AgentType.__init__(self,solution_terminal=deepcopy(ConsumerType.solution_terminal_),cycles=cycles,time_flow=time_flow,pseudo_terminal=False,**kwds)

        # Add consumer-type specific objects, copying to create independent versions
        self.time_vary = deepcopy(ConsumerType.time_vary_)
        self.time_inv = deepcopy(ConsumerType.time_inv_)
        self.solveAPeriod = consumptionSavingSolverCubic # this can be swapped for consumptionSavingSolverLinear or another solver

    def unpack_cFunc(self):
        '''
        "Unpacks" the consumption functions into their own field for easier access.
        After the model has been solved, the consumption functions reside in the
        attribute cFunc of each element of ConsumerType.solution.  This method
        creates a (time varying) attribute cFunc that contains a list of consumption
        functions.
        '''
        self.cFunc = []
        for solution_t in self.solution:
            self.cFunc.append(solution_t.cFunc)
        if not ('cFunc' in self.time_vary):
            self.time_vary.append('cFunc')
            
    def addIncomeShockPaths(self,perm_shocks,temp_shocks):
        '''
        Adds paths of simulated shocks to the agent as attributes.
        '''
        original_time = self.time_flow
        self.timeRev()
        self.perm_shocks = perm_shocks
        self.temp_shocks = temp_shocks
        if not 'perm_shocks' in self.time_vary:
            self.time_vary.append('perm_shocks')
        if not 'temp_shocks' in self.time_vary:
            self.time_vary.append('temp_shocks')
        if original_time:
            self.timeFwd()
            
    def updateIncomeProcess(self):
        '''
        Updates this agent's income process based on his own attributes.  The
        function that generates the discrete income process can be swapped out
        for a different process.
        '''
        original_time = self.time_flow
        self.timeRev()
        income_distrib, p_zero_income = constructLognormalIncomeProcessUnemployment(self)
        self.income_distrib = income_distrib
        self.p_zero_income = p_zero_income
        if original_time:
            self.timeFwd()
            
    def updateAssetsGrid(self):
        '''
       Updates this agent's end-of-period assets grid.
        '''
        a_grid = constructAssetsGrid(self)
        self.a_grid = a_grid
        
    def update(self):
        '''
        Update the income process and the assets grid.
        '''
        self.updateIncomeProcess()
        self.updateAssetsGrid()
        
            
    def simulate(self,w_init,t_first,t_last):
        '''
        Simulate the model forward from initial conditions w_init, beginning in
        t_first and ending in t_last.
        '''
        original_time = self.time_flow
        self.timeFwd()
        if self.cycles > 0:
            cFuncs = self.cFunc[t_first:t_last]
        else:
            cFuncs = t_last*self.cFunc
        simulated_wealth_matrix = simulateWealthHistory(cFuncs, w_init, self.perm_shocks[t_first:t_last], self.temp_shocks[t_first:t_last])
        if not original_time:
            self.timeRev()
        return simulated_wealth_matrix


    
    
def simulateWealthHistory(cFunc, w0, scriptR, xi):
    """
    Generates simulated histories of wealth-to-permanent-income ratios.  Agents begin
    with W/Y ratio of of w0 and follow the consumption rules in cFunc each period.
    Permanent and transitory shocks are provided in scriptR and xi.  Note that
    scriptR represents R*psi_{it}/Gamma_t, the "effective interest factor" for
    agent i in period t.  Further, the object of interest w is the wealth-to-permanent-
    income ratio at the beginning of the period, before income is received.
    """
    # Initialize an array to hold simulated wealth data (faster than dynamic sizing)
    periods_to_simulate = len(xi)
    N_agents = len(xi[0])
    w = np.zeros([periods_to_simulate+1,N_agents]) + np.nan   

    # Run the simulation for all agents:
    w[0,] = w0
    for t in range(periods_to_simulate):
        m_t = w[t,] + xi[t]
        c_t = cFunc[t](m_t)
        a_t = m_t - c_t
        w[t+1,] = scriptR[t]*a_t
        
    return w
    
    
    
def simulateMoneyHistory(cFunc, w0, scriptR, xi):
    """
    Generates simulated histories of cash resources on hand.  Agents begin
    with W/Y ratio of of w0 and follow the consumption rules in cFunc each period.
    Permanent and transitory shocks are provided in scriptR and xi.
    """
    # Initialize an array to hold simulated wealth data (faster than dynamic sizing)
    periods_to_simulate = len(xi)
    N_agents = len(xi[0])
    m = np.zeros([periods_to_simulate,N_agents]) + np.nan   

    # Run the simulation for all agents:
    w_t = w0
    for t in range(periods_to_simulate):
        m_t = w_t + xi[t]
        c_t = cFunc[t](m_t)
        a_t = m_t - c_t
        w_t = scriptR[t]*a_t
        m[t,] = m_t        
        
    return m
    
    
def simulateMPChistory(cFunc, w0, scriptR, xi):
    """
    Generates simulated histories of marginal propensities to consume.  Agents begin
    with W/Y ratio of of w0 and follow the consumption rules in cFunc each period.
    Permanent and transitory shocks are provided in scriptR and xi.
    """
    # Initialize an array to hold simulated wealth data (faster than dynamic sizing)
    periods_to_simulate = len(xi)
    N_agents = len(xi[0])
    kappa = np.zeros([periods_to_simulate,N_agents]) + np.nan   

    # Run the simulation for all agents:
    w_t = w0
    for t in range(periods_to_simulate):
        m_t = w_t + xi[t]
        c_t, kappa_t = cFunc[t].eval_with_derivative(m_t)
        #kappa[t,] = kappa_t            # Store as quarterly MPC
        kappa[t,] = 1-(1 - kappa_t)**4 # Store as annual MPC
        a_t = m_t - c_t
        w_t = scriptR[t]*a_t
        
    return kappa


# ==================================================================================
# = Functions for generating discrete income processes and simulated income shocks =
# ==================================================================================

def constructLognormalIncomeProcessUnemployment(parameters):
    """
    Generates a list of discrete approximations to the income process for each
    life period, from end of life to beginning of life.  Permanent shocks are mean
    one lognormally distributed with standard deviation psi_sigma[t] during the
    working life, and degenerate at 1 in the retirement period.  Transitory shocks
    are mean one lognormally distributed with a point mass at income_unemploy with
    probability p_unemploy while working; they are mean one with a point mass at
    income_unemploy_retire with probability p_unemploy_retire.  Retirement occurs
    after t=final_work_index periods of retirement.

    Note 1: All time in this function runs backward, from t=T to t=0
    
    Note 2: All parameters are passed as attributes of the input parameters.

    Parameters:
    -----------
    psi_sigma:    [float]
        Array of standard deviations in _permanent_ income uncertainty during
        the agent's life.
    psi_N:      int
        The number of approximation points to be used in the equiprobable
        discrete approximation to the permanent income shock distribution.
    xi_sigma      [float]
        Array of standard deviations in _temporary_ income uncertainty during
        the agent's life.
    xi_N:       int
        The number of approximation points to be used in the equiprobable
        discrete approximation to the permanent income shock distribution.
    p_unemploy:             float
        The probability of becoming unemployed
    p_unemploy_retire:      float
        The probability of not receiving typical retirement income in any retired period
    T_retire:       int
        The index value i equal to the final working period in the agent's life.
        If final_work_index < 0 then there is no retirement.
    income_unemploy:         float
        Income received when unemployed. Often zero.
    income_unemploy_retire:  float
        Income received while "unemployed" when retired. Often zero.
    T_total:       int
        Total number of non-terminal periods in this consumer's life.

    Returns
    =======
    income_distrib:  [income distribution]
        Each element contains the joint distribution of permanent and transitory
        income shocks, as a set of vectors: psi_shock, xi_shock, and pmf. The
        first two are the points in the joint state space, and final vector is
        the joint pmf over those points. For example,
               psi_shock[20], xi_shock[20], and pmf[20]
        refers to the (psi, xi) point indexed by 20, with probability p = pmf[20].
    p_zero_income: [float]
        A list of probabilities of receiving exactly zero income in each period.

    """
    # Unpack the parameters from the input
    psi_sigma = parameters.psi_sigma
    psi_N = parameters.psi_N
    xi_sigma = parameters.xi_sigma
    xi_N = parameters.xi_N
    T_total = parameters.T_total
    T_retire = parameters.T_retire
    p_unemploy = parameters.p_unemploy
    income_unemploy = parameters.income_unemploy
    p_unemploy_retire = parameters.p_unemploy_retire        
    income_unemploy_retire = parameters.income_unemploy_retire
    
    income_distrib = [] # Discrete approximation to income process
    p_zero_income = [] # Probability of zero income in each period of life

    # Fill out a simple discrete RV for retirement, with value 1.0 (mean of shocks)
    # in normal times; value 0.0 in "unemployment" times with small prob.
    if T_retire >= 0:
        if p_unemploy_retire > 0:
            retire_perm_income_values = np.array([1.0, 1.0])    # Permanent income is deterministic in retirement (2 states for temp income shocks)
            retire_income_values = np.array([income_unemploy_retire, (1.0-p_unemploy_retire*income_unemploy_retire)/(1.0-p_unemploy_retire)])
            retire_income_probs = np.array([p_unemploy_retire, 1.0-p_unemploy_retire])
        else:
            retire_perm_income_values = np.array([1.0])
            retire_income_values = np.array([1.0])
            retire_income_probs = np.array([1.0])
        income_dist_retire = [retire_perm_income_values,retire_income_values,retire_income_probs]

    # Loop to fill in the list of income_distrib random variables.
    for Tminust in range(T_total): # Iterate over all periods, counting back from the final period.

        if T_retire >= 0 and Tminust < T_retire:
            # Then we are in the "retirement period" and add a retirement income object.
            income_distrib.append(deepcopy(income_dist_retire))
            if income_unemploy_retire == 0:
                p_zero_income.append(p_unemploy_retire)
            else:
                p_zero_income.append(0)
        else:
            # We are in the "working life" periods.
            temp_xi_dist = calculateMeanOneLognormalDiscreteApprox(N=xi_N, sigma=xi_sigma[Tminust])
            if p_unemploy > 0:
                temp_xi_dist = addDiscreteOutcomeConstantMean(temp_xi_dist, p=p_unemploy, x=income_unemploy)
            temp_psi_dist = calculateMeanOneLognormalDiscreteApprox(N=psi_N, sigma=psi_sigma[Tminust])
            income_distrib.append(createFlatStateSpaceFromIndepDiscreteProbs(temp_psi_dist, temp_xi_dist))
            if income_unemploy == 0:
                p_zero_income.append(p_unemploy)
            else:
                p_zero_income.append(0)

    return income_distrib, p_zero_income
    
    
    
def constructLognormalIncomeProcessUnemploymentFailure(parameters):
    """
    Generates a list of discrete approximations to the income process for each
    life period, from end of life to beginning of life.  The process is identical
    to constructLognormalIncomeProcessUnemployment but for a very tiny possibility
    that unemployment benefits are not provided.

    Parameters:
    -----------
    psi_sigma:    [float]
        Array of standard deviations in _permanent_ income uncertainty during
        the agent's life.
    psi_N:      int
        The number of approximation points to be used in the equiprobable
        discrete approximation to the permanent income shock distribution.
    xi_sigma      [float]
        Array of standard deviations in _temporary_ income uncertainty during
        the agent's life.
    xi_N:       int
        The number of approximation points to be used in the equiprobable
        discrete approximation to the permanent income shock distribution.
    p_unemploy:             float
        The probability of becoming unemployed
    p_unemploy_retire:      float
        The probability of not receiving typical retirement income in any retired period
    T_retire:       int
        The index value i equal to the final working period in the agent's life.
        If final_work_index < 0 then there is no retirement.
    income_unemploy:         float
        Income received when unemployed. Often zero.
    income_unemploy_retire:  float
        Income received while "unemployed" when retired. Often zero.
    T_total:       int
        Total number of non-terminal periods in this consumer's life.

    Returns
    =======
    income_distrib:  [income distribution]
        Each element contains the joint distribution of permanent and transitory
        income shocks, as a set of vectors: psi_shock, xi_shock, and pmf. The
        first two are the points in the joint state space, and final vector is
        the joint pmf over those points. For example,
               psi_shock[20], xi_shock[20], and pmf[20]
        refers to the (psi, xi) point indexed by 20, with probability p = pmf[20].
    p_zero_income: [float]
        A list of probabilities of receiving exactly zero income in each period.

    """
    # Unpack the parameters from the input
    psi_sigma = parameters.psi_sigma
    psi_N = parameters.psi_N
    xi_sigma = parameters.xi_sigma
    xi_N = parameters.xi_N
    T_total = parameters.T_total
    p_unemploy = parameters.p_unemploy
    p_unemploy_retire = parameters.p_unemploy_retire
    T_retire = parameters.T_retire
    income_unemploy = parameters.income_unemploy
    income_unemploy_retire = parameters.income_unemploy_retire

    # Set a small possibility of unemployment benefit failure
    p_fail = 0.01
    
    income_distrib = [] # Discrete approximation to income process
    p_zero_income = [] # Probability of zero income in each period of life

    # Fill out a simple discrete RV for retirement, with value 1.0 (mean of shocks)
    # in normal times; value 0.0 in "unemployment" times with small prob.
    if T_retire >= 0:
        if p_unemploy_retire > 0:
            retire_perm_income_values = np.array([1.0, 1.0])    # Permanent income is deterministic in retirement (2 states for temp income shocks)
            retire_income_values = np.array([income_unemploy_retire, (1.0-p_unemploy_retire*income_unemploy_retire)/(1.0-p_unemploy_retire)])
            retire_income_probs = np.array([p_unemploy_retire, 1.0-p_unemploy_retire])
            if income_unemploy_retire > 0:
                temp_dist = addDiscreteOutcomeConstantMean([retire_income_values, retire_income_probs], p=(p_fail*p_unemploy_retire), x=0)
                retire_income_values = temp_dist[0]
                retire_income_probs = temp_dist[1]
                retire_perm_income_values = np.array([1.0, 1.0, 1.0])
        else:
            retire_perm_income_values = np.array([1.0])
            retire_income_values = np.array([1.0])
            retire_income_probs = np.array([1.0])
        income_dist_retire = [retire_perm_income_values,retire_income_values,retire_income_probs]


    # Loop to fill in the list of income_distrib random variables.
    for Tminust in range(T_total): # Iterate over all periods, counting back from the final period.

        if T_retire >= 0 and Tminust < T_retire:
            # Then we are in the "retirement period" and add a retirement income object.
            income_distrib.append(deepcopy(income_dist_retire))
            if income_unemploy_retire == 0:
                p_zero_income.append(p_unemploy_retire)
            else:
                p_zero_income.append(p_fail*p_unemploy_retire)
        else:
            # We are in the "working life" periods.
            temp_xi_dist = calculateMeanOneLognormalDiscreteApprox(N=xi_N, sigma=xi_sigma[Tminust])
            if p_unemploy > 0:
                temp_xi_dist = addDiscreteOutcomeConstantMean(temp_xi_dist, p=p_unemploy, x=income_unemploy)
                if income_unemploy > 0:
                    temp_xi_dist = addDiscreteOutcomeConstantMean(temp_xi_dist, p=(p_unemploy*p_fail), x=0)
            temp_psi_dist = calculateMeanOneLognormalDiscreteApprox(N=psi_N, sigma=psi_sigma[Tminust])
            income_distrib.append(createFlatStateSpaceFromIndepDiscreteProbs(temp_psi_dist, temp_xi_dist))
            if p_unemploy > 0:
                if income_unemploy == 0:
                    p_zero_income.append(p_unemploy)
                else:
                    p_zero_income.append(p_unemploy*p_fail)
            else:
                p_zero_income.append(0)

    return income_distrib, p_zero_income

def applyFlatIncomeTax(income_distrib,tax_rate,T_retire,unemployed_indices=[],transitory_index=1):
    '''
    Applies a flat income tax rate to all employed income states during the working
    period of life (those after T_retire).  Time runs backward in this function.
    
    Parameters:
    -------------
    income_distrib : [income distributions]
        The discrete approximation to the income distribution in each time period.
    tax_rate : float
        A flat income tax rate to be applied to all employed income.
    T_retire : int
        The number of retirement periods (income tax not charged).
    unemployed_indices : [int]
        Indices of transitory shocks that represent unemployment states (no tax).
    transitory_index : int
        The index of each element of income_distrib representing transitory shocks.
        
    Returns:
    ------------
    income_distrib_new : [income distributions]
        The updated income distributions, after applying the tax.
    '''
    income_distrib_new = deepcopy(income_distrib)
    i = transitory_index
    for t in range(len(income_distrib)):
        if t >= T_retire:
            for j in range((income_distrib[t][i]).size):
                if j not in unemployed_indices:
                    income_distrib_new[t][i][j] = income_distrib[t][i][j]*(1-tax_rate)
    return income_distrib_new
   
    
    
def generateIncomeShockHistoryLognormalUnemployment(parameters):
    '''
    Creates arrays of permanent and transitory income shocks for Nagents simulated
    consumers for the entire duration of the lifecycle.  All inputs are assumed
    to be given in reverse chronological order, from terminal period to t=0.
    Output is also returned in reverse chronological order.
    
    Arguments:
    ----------
    psi_sigma : [float]
        Permanent income standard deviations for the consumer by age.  Note that
        psi_sigma[:final_work_index] are irrelevant due to retirement.
    xi_sigma : [float]
        Transitory income standard devisions for the consumer by age.  Note that
        xi_sigma[:final_work_index] are irrelevant due to retirement.
    Gamma : [float]
        Permanent income growth rates for the consumer by age.
    R : [float]
        The time-invariant interest factor
    p_unemploy : float
        The probability of becoming unemployed
    p_unemploy_retire : float
        The probability of not receiving typical retirement income in any retired period
    T_retire : int
        The index value for final working period in the agent's life.
        If final_work_index < 0 then there is no retirement.
    income_unemploy : float
        Income received when unemployed. Often zero.
    income_unemploy_retire : float
        Income received while "unemployed" when retired. Often zero.
    Nagents : int
        The number of consumers to generate shocks for.
    tax_rate : float
        An income tax rate applied to employed income.
    psi_seed : int
        Seed for random number generator, permanent income shocks.
    xi_seed : int
        Seed for random number generator, temporary income shocks.
    unemp_seed : int
        Seed for random number generator, unemployment shocks.

    Returns:
    ----------
    scriptR_history : np.array
        A total_periods x Nagents array of permanent income shocks.  Each element
        is a value representing R/(psi_{it}*Gamma_t), so that w_{t+1} = scriptR_{it}*a_t
    xi_history : np.array
        A total_periods x Nagents array of transitory income shocks.
    '''
    # Unpack the parameters
    psi_sigma = parameters.psi_sigma
    xi_sigma = parameters.xi_sigma
    Gamma = parameters.Gamma
    R = parameters.R
    p_unemploy = parameters.p_unemploy
    p_unemploy_retire = parameters.p_unemploy_retire
    income_unemploy = parameters.income_unemploy
    income_unemploy_retire = parameters.income_unemploy_retire
    T_retire = parameters.T_retire
    Nagents = parameters.Nagents
    psi_seed = parameters.psi_seed
    xi_seed = parameters.xi_seed
    unemp_seed = parameters.unemp_seed
    tax_rate = parameters.tax_rate

    # Truncate the lifecycle vectors to the working life
    #T_retire = T_retire-1 # indexing adjustment
    psi_sigma_working = psi_sigma[T_retire:]
    xi_sigma_working = xi_sigma[T_retire:]
    Gamma_working = Gamma[T_retire:]
    Gamma_retire = Gamma[0:T_retire]
    
    # Generate transitory shocks in the working period (needs one extra period)
    xi_history_working = generateMeanOneLognormalDraws(xi_sigma_working, Nagents, xi_seed)
    np.random.seed(0)
    xi_history_working.append(np.random.permutation(xi_history_working[-1]))
    
    # Generate permanent shocks in the working period
    scriptR_history_working = generateMeanOneLognormalDraws(psi_sigma_working, Nagents, psi_seed)
    for t in range(len(Gamma_working)):
        scriptR_history_working[t] = R/(scriptR_history_working[t]*Gamma_working[t])

    # Generate permanent and transitory shocks for the retired period
    xi_history_retired = []
    scriptR_history_retired = []
    for t in range(T_retire):
        xi_history_retired.append(np.ones([Nagents]))
        scriptR_history_retired.append(R*np.ones([Nagents])/Gamma_retire[t])
    scriptR_history_retired.append(R*np.ones([Nagents]))
    
    # Generate draws of unemployment
    p_unemploy_life = [p_unemploy_retire]*T_retire + [p_unemploy]*(len(psi_sigma_working)+1)
    income_unemploy_life = [income_unemploy_retire]*T_retire + [income_unemploy]*(len(psi_sigma_working)+1)
    unemp_rescale_life = [(1-p_unemploy_retire*income_unemploy_retire)/(1-p_unemploy_retire)]*T_retire + [(1-tax_rate)*(1-p_unemploy*income_unemploy)/(1-p_unemploy)]*(len(psi_sigma_working)+1)
    unemployment_history = generateBernoulliDraws(p_unemploy_life,Nagents,unemp_seed)   
    
    # Combine working and retired histories and apply unemployment
    xi_history = xi_history_retired + xi_history_working
    scriptR_history = scriptR_history_retired + scriptR_history_working
    for t in range(len(xi_history)):
        xi_history[t] = xi_history[t]*unemp_rescale_life[t]
        xi_history[t][unemployment_history[t]] = income_unemploy_life[t]
    
    return scriptR_history, xi_history
    
    
def generateIncomeShockHistoryInfiniteSimple(parameters):
    '''
    Creates arrays of permanent and transitory income shocks for Nagents simulated
    consumers for T identical infinite horizon periods.
    
    Arguments:
    ----------
    psi_sigma : float
        Permanent income standard deviation for the consumer.
    xi_sigma : float
        Transitory income standard deviation for the consumer.
    Gamma : float
        Permanent income growth rate for the consumer.
    R : float
        The time-invariant interest factor
    p_unemploy : float
        The probability of becoming unemployed
    income_unemploy : float
        Income received when unemployed. Often zero.
    Nagents : int
        The number of consumers to generate shocks for.
    psi_seed : int
        Seed for random number generator, permanent income shocks.
    xi_seed : int
        Seed for random number generator, temporary income shocks.
    unemp_seed : int
        Seed for random number generator, unemployment shocks.
    sim_periods : int
        Number of periods of shocks to generate.
    
    Returns:
    ----------
    scriptR_history : np.array
        A sim_periods x Nagents array of permanent income shocks.  Each element
        is a value representing R*psi_{it}/Gamma_t, so that w_{t+1} = scriptR_{it}*a_t
    xi_history : np.array
        A sim_periods x Nagents array of transitory income shocks.
    '''
    # Unpack the parameters
    psi_sigma = parameters.psi_sigma
    xi_sigma = parameters.xi_sigma
    Gamma = parameters.Gamma
    R = parameters.R
    p_unemploy = parameters.p_unemploy
    income_unemploy = parameters.income_unemploy
    Nagents = parameters.Nagents
    psi_seed = parameters.psi_seed
    xi_seed = parameters.xi_seed
    unemp_seed = parameters.unemp_seed
    sim_periods = parameters.sim_periods
    
    xi_history = generateMeanOneLognormalDraws(sim_periods*xi_sigma, Nagents, xi_seed)
    unemployment_history = generateBernoulliDraws(sim_periods*[p_unemploy],Nagents,unemp_seed)
    scriptR_history = generateMeanOneLognormalDraws(sim_periods*psi_sigma, Nagents, psi_seed)
    for t in range(sim_periods):
        scriptR_history[t] = R/(scriptR_history[t]*Gamma)
        xi_history[t] = xi_history[t]*(1-p_unemploy*income_unemploy)/(1-p_unemploy)
        xi_history[t][unemployment_history[t]] = income_unemploy
        
    return scriptR_history, xi_history

# =======================================================
# ================ Other useful functions ===============
# =======================================================

def constructAssetsGrid(parameters):
    '''
    Constructs the grid of post-decision states, representing end-of-period assets.

    All parameters are passed as attributes of the single input parameters.  The
    input can be an instance of a ConsumerType, or a custom Parameters class.    
    
    Parameters:
    -----------
    a_min:                  float
        Minimum value for the a-grid
    a_max:                  float
        Maximum value for the a-grid
    a_size:                 int
        Size of the a-grid
    a_extra:                [float]
        Extra values for the a-grid.
    grid_type:              string
        String indicating the type of grid. "linear" or "exp_mult"
    exp_nest:               int
        Level of nesting for the exponentially spaced grid
        
    Returns:
    ----------
    a_grid:     np.ndarray
        Base array of values for the post-decision-state grid.
    '''
    # Unpack the parameters
    a_min = parameters.a_min
    a_max = parameters.a_max
    a_size = parameters.a_size
    a_extra = parameters.a_extra
    grid_type = 'exp_mult'
    exp_nest = parameters.exp_nest
    
    # Set up post decision state grid:
    a_grid = None
    if grid_type == "linear":
        a_grid = np.linspace(a_min, a_max, a_size)
    elif grid_type == "exp_mult":
        a_grid = setupGridsExpMult(ming=a_min, maxg=a_max, ng=a_size, timestonest=exp_nest)
    else:
        raise Exception, "grid_type not recognized in __init__. Please ensure grid_type is 'linear' or 'exp_mult'"

    # Add in additional points for the grid:
    for a in a_extra:
        if (a is not None):
            if a not in a_grid:
                j = a_grid.searchsorted(a)
                a_grid = np.insert(a_grid, j, a)

    return a_grid